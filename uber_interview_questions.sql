
-- EASY

Table: sales
+--------------+-----------+
| Column Name  | Type      |
+--------------+-----------+    
| order_id     | int       |
| product_name | var       |
| order_date   | date      |
| customer_name| var       |
| quantity     | int       |
| price        | dec       |  
+--------------+-----------+

-- Question: Write a SQL query to retrieve the total revenue generated by
-- each customer in February 2022, 
-- ordered by total revenue in descending order rounded to the second decimal.
 
 SELECT 
  customer_name, 
  ROUND(SUM(price * quantity), 2) AS total_revenue 
FROM 
  sales 
WHERE 
  YEAR(order_date) = 2022 AND MONTH(order_date) = 2 
GROUP BY 
  customer_name 
ORDER BY 
  total_revenue DESC;


-- QUESTION - 2 

Table: questions
+-------------+-----------+
| Column Name | Type      |
+-------------+-----------+
| question_id | int       |
| "level"     | var       |
| name        | var       |
| added_date  | timestamp |
+-------------+-----------+
Table: members
+-------------+--------------+
| Column Name | Type         |
+-------------+--------------+
| user_id     | int          |    
| question_id | int          |
| start_time  | timestamp    |
| minutes     | int          |
+-------------+--------------+

-- Question: Write a SQL query that returns the total number 
-- of users who attempted each programming question grouped by question ID. 
-- The result should only include questions that have been attempted at 
-- least once and order the output by question ASC.

select 
question_id, 
count(distinct user_id) AS total_users 
from 
members
group by question_id 
order by question_id ASC 


-- QUESTION - 3 
Table: sign_ups
+-----------------------------+---------+
| Column Name                 | Type    |
+-----------------------------+---------+    
|rider_id                     |int      |
|signup_timestamp             |timestamp|
+-----------------------------+---------+
Table: trips
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|trip_id       |int      |
|rider_id      |int      |
|driver_id     |int      |
|trip_timestamp|timestamp|
+--------------+---------+

-- Write a query to find the latest trip timestamp for each user who took at least one trip.
-- Note: Order by rider id ASC"

select 
rider_id, 
MAX(trip_timestamp)
from 
trips 
group by rider_id
having count(trip_id) >=  1 
order by rider_id ASC 






--MEDIUM

--QUESTION 1 
Table: brands
+--------------------+-----------+
| Column Name        | Type      |
+--------------------+-----------+    
|brand_id            |int        |  
|brand_name          |var        |
|holding_company_id  |int        |
|holding_company_name|var        |
+--------------------+-----------+
Table: orders
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|order_id      |int      |      
|user_id       |int      |
|product_id    |int      |
|brand_id      |int      |
|price         |int      |
|quantity      |int      |
|date          |date     |
|store_id      |int      |
+--------------+---------+

-- Write a query to find each Product (ID), and determine the 
-- “store of sale” that made the first sale of the product in 2019.


with cte as (
    select 
    product_id, 
    store_id, 
    row_number() over (partition by product_id order by date asc) as row_number_new 
    from 
    orders 
    where YEAR(date) = 2019
)
select 
product_id, 
store_id
from 
cte 
where row_number_new = 1 


--QUESTION - 2 
Table: brands
+--------------------+-----------+
| Column Name        | Type      |
+--------------------+-----------+    
|brand_id            |int        |  
|brand_name          |var        |
|holding_company_id  |int        |
|holding_company_name|var        |
+--------------------+-----------+
Table: orders
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|order_id      |int      |      
|user_id       |int      |
|product_id    |int      |
|brand_id      |int      |
|price         |int      |
|quantity      |int      |
|date          |date     |
|store_id      |int      |
+--------------+---------+

-- Write a query that will output one row for each Order ID with a column denoting whether 
-- or not the month name of the order date ends in “r”, as well as a column for
-- whether or not the order contained at least one product with a requested quantity greater than 1.

select 
order_id, 
case 
   when RIGHT(MONTHNAME(date),1) = 'r' THEN 'yes'
   ELSE 'No'
end as month_ends_in_r, 
case 
  when MAX(quantity) > 1 THEN 'yes'
  else 'no'
end as has_quantity_gt_1 
from 
orders 
group by 
order_id 


--QUESTION 3 

Table: brands
+--------------------+-----------+
| Column Name        | Type      |
+--------------------+-----------+    
|brand_id            |int        |  
|brand_name          |var        |
|holding_company_id  |int        |
|holding_company_name|var        |
+--------------------+-----------+
Table: orders
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|order_id      |int      |      
|user_id       |int      |
|product_id    |int      |
|brand_id      |int      |
|price         |int      |
|quantity      |int      |
|date          |date     |
|store_id      |int      |
+--------------+---------+

-- Write a query to find the user ids of those who placed a third order on
-- or after 9/21/22 with at least one order from the ATG holding company.

WITH ranked_orders AS (
  SELECT 
    o.user_id,
    o.date,
    b.holding_company_name,
    ROW_NUMBER() OVER (PARTITION BY o.user_id ORDER BY o.date) AS order_num
  FROM 
    orders o
  JOIN 
    brands b ON o.brand_id = b.brand_id
)

SELECT DISTINCT user_id
FROM ranked_orders
WHERE 
  order_num = 3
  AND date >= '2022-09-21'
  AND holding_company_name = 'ATG';

--QUESTION 4 
Table: complaints
+------------------+-----------+
| Column Name      | Type      |
+------------------+-----------+    
|complaint_id      |int        |  
|id                |id         |
|date              |date       |
|complaint_type    |var        |
|complaint_content |var        |
+------------------+-----------+
Table: processed_complaints
+------------------+-----------+
| Column Name      | Type      |
+------------------+-----------+    
|complaint_id      |int        |  
|processed         |boo        |
|processing_date   |date       |
+------------------+-----------+
-- Write a query to find the share of processed complaints by type of complaint. 
-- Round the number to 2 decimal places.

SELECT 
  c.complaint_type,
  ROUND(
    SUM(CASE WHEN pc.processed = true THEN 1 ELSE 0 END) * 1.0 
    / COUNT(*), 
    2
  ) AS processed_share
FROM 
  complaints c
LEFT JOIN 
  processed_complaints pc ON c.complaint_id = pc.complaint_id
GROUP BY 
  c.complaint_type;


--HARD-- 

--QUESTION -1 
Table: records
+------------+----------+
|Column Name |Type      |
+------------+----------+    
|record      |var       |  
+------------+----------+
Write a regular expression pattern to match valid data entries with at least one store.

Hint: Store IDs are always pure integers formatted like stores-47.

Example

Table: records
+--------------------------+
|          record          |
+--------------------------+
|stores-35|120|530         |
|stores-47                 |
|stores-427|3619|12|36|490 |
|stores-24|                |
|stores-25|29||58          |
|stores-24s|z29            |
|storiees-25|29|58         |
|the-stores-25|29|58       |
|stores-25|29|58-end       |
+--------------------------+

SELECT *
FROM records
WHERE record ~ '\bstores-\d+\b';

--QUESTION 2 

Table: sign_ups
+-----------------------------+---------+
| Column Name                 | Type    |
+-----------------------------+---------+    
|rider_id                     |int      |
|signup_timestamp             |timestamp|
+-----------------------------+---------+
Table: trips
+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
|trip_id       |int      |
|rider_id      |int      |
|driver_id     |int      |
|trip_timestamp|timestamp|
+--------------+---------+
-- Write a query to find for each user that has taken at least two trips with Uber, 
-- what is the time that elapsed between first trip and second trip?

WITH ranked_trips AS (
  SELECT
    rider_id,
    trip_timestamp,
    ROW_NUMBER() OVER (PARTITION BY rider_id ORDER BY trip_timestamp) AS trip_rank,
    LAG(trip_timestamp) OVER (PARTITION BY rider_id ORDER BY trip_timestamp) AS prev_trip
  FROM trips
)
SELECT
  rider_id,
  trip_timestamp - prev_trip AS time_elapsed
FROM
  ranked_trips
WHERE 
  trip_rank = 2;